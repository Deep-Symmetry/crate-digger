meta:
  id: rekordbox_pdb
  title: DeviceSQL database export (probably generated by rekordbox)
  application: rekordbox
  file-extension:
    - pdb
  license: EPL-1.0
  endian: le

doc: |
  This is a relational database format designed to be efficiently used
  by very low power devices (there were deployments on 16 bit devices
  with 32K of RAM). Today you are most likely to encounter it within
  the Pioneer Professional DJ ecosystem, because it is the format that
  their rekordbox software uses to write USB and SD media which can be
  mounted in DJ controllers and used to play and mix music.

  It has been reverse-engineered to facilitate sophisticated
  integrations with light and laser shows, videos, and other musical
  instruments, by supporting deep knowledge of what is playing and
  what is coming next through monitoring the network communications of
  the players.

  The file is divided into fixed-size blocks. The first block has a
  header that establishes the block size, and lists the tables
  available in the database, identifying their types and the index of
  the first of the series of linked pages that make up that table.

  Each table is made up of a series of rows which may be spread across
  any number of pages. The pages start with a header describing the
  page and linking to the next page. The rest of the page is used as a
  heap: rows are scattered around it, and located using an index
  structure that builds backwards from the end of the page. Each row
  of a given type has a fixed size structure which links to any
  variable-sized strings by their offsets within the page.

  As changes are made to the table, some records may become unused,
  and there may be gaps within the heap that are too small to be used
  by other data. There is a bit map in the row index that identifies
  which rows are actually present. Rows that are not present must be
  ignored: they do not contain valid (or even necessarily well-formed)
  data.

  The majority of the work in reverse-engineering this format was
  performed by @henrybetts and @flesniak, for which I am hugely
  grateful. @GreyCat helped me learn the intricacies (and best
  practices) of Kaitai far faster than I would have managed on my own.

doc-ref: https://github.com/Deep-Symmetry/crate-digger/blob/master/doc/Analysis.pdf

seq:
  - type: u4
    doc: |
      Unknown purpose, perhaps an unoriginal signature, seems to
      always have the value 0.
  - id: len_page
    type: u4
    doc: |
      The database page size, in bytes. Pages are referred to by
      index, so this size is needed to calculate their offset, and
      table pages have a row index structure which is built from the
      end of the page backwards, so finding that also requires this
      value.
  - id: num_tables
    type: u4
    doc: |
      Determines the number of table entries that are present. Each
      table is a linked list of pages containing rows of a particular
      type.
  - id: next_unused_page
    type: u4
    doc: |
      @flesniak said: "Not used as any `empty_candidate`, points
      past the end of the file."
  - type: u4
  - id: sequence
    type: u4
    doc: |
      @flesniak said: "Always incremented by at least one,
      sometimes by two or three."
  - id: gap
    contents: [0, 0, 0, 0]
    doc: |
      Only exposed until
      https://github.com/kaitai-io/kaitai_struct/issues/825 can be
      fixed.
  - id: tables
    type: table
    repeat: expr
    repeat-expr: num_tables
    doc: |
      Describes and links to the tables present in the database.

types:
  table:
    doc: |
      Each table is a linked list of pages containing rows of a single
      type. This header describes the nature of the table and links to
      its pages by index.
    seq:
      - id: type
        type: u4
        enum: page_type
        doc: |
          Identifies the kind of rows that are found in this table.
      - id: empty_candidate
        type: u4
      - id: first_page
        type: page_ref
        doc: |
          Links to the chain of pages making up that table. The first
          page seems to always contain similar garbage patterns and
          zero rows, but the next page it links to contains the start
          of the meaningful data rows.
      - id: last_page
        type: page_ref
        doc: |
          Holds the index of the last page that makes up this table.
          When following the linked list of pages of the table, you
          either need to stop when you reach this page, or when you
          notice that the `next_page` link you followed took you to a
          page of a different `type`.
    -webide-representation: '{type}'

  page_ref:
    doc: |
      An index which points to a table page (its offset can be found
      by multiplying the index by the `page_len` value in the file
      header). This type allows the linked page to be lazy loaded.
    seq:
      - id: index
        type: u4
        doc: |
          Identifies the desired page number.
    instances:
      body:
        doc: |
          When referenced, loads the specified page and parses its
          contents appropriately for the type of data it contains.
        io: _root._io
        pos: _root.len_page * index
        size: _root.len_page
        type: page
        if: index > 0x0

  page:
    doc: |
      A table page, consisting of a short header describing the
      content of the page and linking to the next page, followed by a
      heap in which row data is found. At the end of the page there is
      an index which locates all rows present in the heap via their
      offsets past the end of the page header.
    seq:
      - id: gap
        contents: [0, 0, 0, 0]
        doc: |
          Only exposed until
          https://github.com/kaitai-io/kaitai_struct/issues/825 can be
          fixed.
      - id: page_index
        doc: Matches the index we used to look up the page, sanity check?
        type: u4
      - id: type
        type: u4
        enum: page_type
        doc: |
          Identifies the type of information stored in the rows of this page.
      - id: next_page
        doc: |
          Index of the next page containing this type of rows. Points past
          the end of the file if there are no more.
        type: page_ref
      - type: u4
        doc: |
          @flesniak said: "sequence number (0->1: 8->13, 1->2: 22, 2->3: 27)"
      - size: 4
      - id: num_rows_small
        type: u1
        doc: |
          Holds the value used for `num_rows` (see below) unless
          `num_rows_large` is larger (but not equal to `0x1fff`). This
          seems like some strange mechanism to deal with the fact that
          lots of tiny entries, such as are found in the
          `playlist_entries` table, are too big to count with a single
          byte. But why not just always use `num_rows_large`, then?
      - type: u1
        doc: |
          @flesniak said: "a bitmask (1st track: 32)"
      - type: u1
        doc: |
          @flesniak said: "often 0, sometimes larger, esp. for pages
          with high real_entry_count (e.g. 12 for 101 entries)"
      - id: page_flags
        type: u1
        doc: |
          @flesniak said: "strange pages: 0x44, 0x64; otherwise seen: 0x24, 0x34"
      - id: free_size
        type: u2
        doc: |
          Unused space (in bytes) in the page heap, excluding the row
          index at end of page.
      - id: used_size
        type: u2
        doc: |
          The number of bytes that are in use in the page heap.
      - type: u2
        doc: |
          @flesniak said: "(0->1: 2)"
      - id: num_rows_large
        type: u2
        doc: |
          Holds the value used for `num_rows` (as described above)
          when that is too large to fit into `num_rows_small`, and
          that situation seems to be indicated when this value is
          larger than `num_rows_small`, but not equal to `0x1fff`.
          This seems like some strange mechanism to deal with the fact
          that lots of tiny entries, such as are found in the
          `playlist_entries` table, are too big to count with a single
          byte. But why not just always use this value, then?
      - type: u2
        doc: |
          @flesniak said: "1004 for strange blocks, 0 otherwise"
      - type: u2
        doc: |
          @flesniak said: "always 0 except 1 for history pages, num
          entries for strange pages?"
      - id: heap
        size-eos: true
        if: false  # never true, but stores pos
    instances:
      is_data_page:
        value: page_flags & 0x40 == 0
        -webide-parse-mode: eager
      heap_pos:
        value: _io.pos
      num_rows:
        value: |
          (num_rows_large > num_rows_small) and (num_rows_large != 0x1fff) ? num_rows_large : num_rows_small
        doc: |
          The number of rows that have ever been allocated on this
          page (controls the number of row groups there are, but some
          entries in each group may not be marked as present in the
          table due to deletion or updates).
        -webide-parse-mode: eager
      num_row_groups:
        value: '(num_rows - 1) / 16 + 1'
        doc: |
          The number of row groups that are present in the index. Each
          group can hold up to sixteen rows, but `row_present_flags`
          must be consulted to determine whether each is valid.
      row_groups:
        type: 'row_group(_index)'
        repeat: expr
        repeat-expr: num_row_groups
        doc: |
          The actual row groups making up the row index. Each group
          can hold up to sixteen rows. Non-data pages do not have
          actual rows, and attempting to parse them can crash.
        if: is_data_page

  row_group:
    doc: |
      A group of row indices, which are built backwards from the end
      of the page. Holds up to sixteen row offsets, along with a bit
      mask that indicates whether each row is actually present in the
      table.
    params:
      - id: group_index
        type: u2
        doc: |
          Identifies which group is being generated. They build backwards
          from the end of the page.
    instances:
      base:
        value: '_root.len_page - (group_index * 0x24)'
        doc: |
          The starting point of this group of row indices.
      row_present_flags:
        pos: base - 4
        type: u2
        doc: |
          Each bit specifies whether a particular row is present. The
          low order bit corresponds to the first row in this index,
          whose offset immediately precedes these flag bits. The
          second bit corresponds to the row whose offset precedes
          that, and so on.
        -webide-parse-mode: eager
      rows:
        type: row_ref(_index)
        repeat: expr
        repeat-expr: 16
        doc: |
          The row offsets in this group.

  row_ref:
    doc: |
      An offset which points to a row in the table, whose actual
      presence is controlled by one of the bits in
      `row_present_flags`. This instance allows the row itself to be
      lazily loaded, unless it is not present, in which case there is
      no content to be loaded.
    params:
      - id: row_index
        type: u2
        doc: |
          Identifies which row within the row index this reference
          came from, so the correct flag can be checked for the row
          presence and the correct row offset can be found.
    instances:
      ofs_row:
        pos: '_parent.base - (6 + (2 * row_index))'
        type: u2
        doc: |
          The offset of the start of the row (in bytes past the end of
          the page header).
      row_base:
        value: ofs_row + _parent._parent.heap_pos
        doc: |
          The location of this row relative to the start of the page.
          A variety of pointers (such as all device_sql_string values)
          are calculated with respect to this position.
      present:
        value: '(((_parent.row_present_flags >> row_index) & 1) != 0 ? true : false)'
        doc: |
          Indicates whether the row index considers this row to be
          present in the table. Will be `false` if the row has been
          deleted.
        -webide-parse-mode: eager
      body:
        pos: row_base
        type:
          switch-on: _parent._parent.type
          cases:
            'page_type::tags': tag_row
            'page_type::tag_tracks': tag_track_row
        if: present
        doc: |
          The actual content of the row, as long as it is present.
        -webide-parse-mode: eager
    -webide-representation: '{body.name.body.text}{body.title.body.text} ({body.id})'

  tag_row:
    doc: |
      A row that holds an tag name and ID.
    seq:
      - type: u2
        doc: |
          Seems to always be 0x80, 0x06.
      - id: tag_index
        type: u2
        doc: |
          Increasing index for each row in multiples of 0x20.
      - type: u8
        doc: |
          Seems to always be zero.
      - id: category
        type: u4
        doc: |
          The index of the tag category this tag belongs to.
          If this row represents a tag category, this field is zero.
      - id: category_pos
        type: u4
        doc: |
          The position of this tag in its category.
          If this row represents a tag category, this field equals (id - 1).
      - id: id
        type: u4
        doc: |
          The ID of this tag or tag category.
          Referenced by tag_track_row if this row is a tag.
      - id: is_category
        type: u4
        doc: |
          Whether this row stores a tag category name instead of a tag.
      - type: u2
        doc: |
          Seems to always be 0x03, 0x1f.
      - id: flags
        type: u1
        doc: |
          Maybe some kind of flags?
      - id: name
        type: device_sql_string
        doc: |
          The name of the tag or tag category.
      - type: u1
        doc: |
          This seems to always be 0x03.

  tag_track_row:
    doc: |
      A row that associates a track and a tag.
    seq:
      - type: u4
        doc: |
          Seems to always be zero.
      - id: track_id
        type: u4
      - id: tag_id
        type: u4
      - type: u4
        doc: |
          Seems to always be 3.

  device_sql_string:
    doc: |
      A variable length string which can be stored in a variety of
      different encodings.
    seq:
      - id: length_and_kind
        type: u1
        doc: |
          Mangled length of an ordinary ASCII string if odd, or a flag
          indicating another encoding with a longer length value to
          follow.
      - id: body
        type:
          switch-on: length_and_kind
          cases:
            0x40: device_sql_long_ascii
            0x90: device_sql_long_utf16le
            _: device_sql_short_ascii(length_and_kind)
        -webide-parse-mode: eager
    -webide-representation: '{body.text}'

  device_sql_short_ascii:
    doc: |
      An ASCII-encoded string up to 127 bytes long.
    params:
      - id: length_and_kind
        type: u1
        doc: |
          Contains the actual length, incremented, doubled, and
          incremented again. Go figure.
    seq:
      - id: text
        type: str
        size: length - 1
        encoding: ASCII
        doc: |
          The content of the string.
    instances:
      length:
        value: '(length_and_kind >> 1)'
        doc: |
          the length extracted of the entire device_sql_short_ascii type
        -webide-parse-mode: eager

  device_sql_long_ascii:
    doc: |
      An ASCII-encoded string preceded by a two-byte length field in a four-byte header.
    seq:
      - id: length
        type: u2
        doc: |
          Contains the length of the string in bytes.
      - type: u1
      - id: text
        type: str
        size: length - 4
        encoding: ASCII
        doc: |
          The content of the string.

  device_sql_long_utf16le:
    doc: |
      A UTF-16LE-encoded string preceded by a two-byte length field in a four-byte header.
    seq:
      - id: length
        type: u2
        doc: |
          Contains the length of the string in bytes, plus four trailing bytes that must be ignored.
      - type: u1
      - id: text
        type: str
        size: length - 4
        encoding: UTF-16LE
        doc: |
          The content of the string.

enums:
  page_type:
    0:
      id: unknown_0
    1:
      id: unknown_1
    2:
      id: unknown_2
    3:
      id: tags
      doc: |
        Holds rows naming tags.
    4:
      id: tag_tracks
      doc: |
        Holds rows associating tags and tracks.
    5:
      id: unknown_5
    6:
      id: unknown_6
    7:
      id: unknown_7
    8:
      id: unknown_8
